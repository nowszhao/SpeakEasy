import SwiftUI

//struct ContentView: View {
//    var body: some View {
//        NavigationView {
//            TopicListView()
//        }
//    }
//}

// Âú®Êñá‰ª∂È°∂ÈÉ®Ê∑ªÂä† FilterType Êûö‰∏æÂÆö‰πâ
enum FilterType: String, CaseIterable {
    case all = "ÂÖ®ÈÉ®"
    case recent = "ÊúÄËøëÈòÖËØª"
    case unreadOnly = "Êú™ËØª"
}

// Âú®Êñá‰ª∂È°∂ÈÉ®Ê∑ªÂä†ÔºåFilterType Êûö‰∏æ‰πãÂâç
struct TextDifference {
    let text: String
    let isMatch: Bool
    let startIndex: Int
    let endIndex: Int
}

func findDifferences(original: String, recognized: String) -> (original: [TextDifference], recognized: [TextDifference]) {
    let originalChars = Array(original)
    let recognizedChars = Array(recognized)
    
    let m = originalChars.count
    let n = recognizedChars.count
    
    // Âä®ÊÄÅËßÑÂàíË°®
    var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1)
    
    // Â°´ÂÖÖ DP Ë°®
    for i in 1...m {
        for j in 1...n {
            if originalChars[i - 1] == recognizedChars[j - 1] {
                dp[i][j] = dp[i - 1][j - 1] + 1
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
            }
        }
    }
    
    // ÂõûÊ∫ØÊâæÂá∫ LCS
    var lcs: [Character] = []
    var i = m, j = n
    while i > 0 && j > 0 {
        if originalChars[i - 1] == recognizedChars[j - 1] {
            lcs.insert(originalChars[i - 1], at: 0)
            i -= 1
            j -= 1
        } else if dp[i - 1][j] > dp[i][j - 1] {
            i -= 1
        } else {
            j -= 1
        }
    }
    
    // Ê†áËÆ∞‰∏çÂåπÈÖçÁöÑÂ≠óÁ¨¶
    var originalDiffs: [TextDifference] = []
    var lcsIndex = 0
    var currentMismatch = ""
    var startIndex = 0
    
    for (index, char) in originalChars.enumerated() {
        if lcsIndex < lcs.count && char == lcs[lcsIndex] {
            if !currentMismatch.isEmpty {
                originalDiffs.append(TextDifference(
                    text: currentMismatch,
                    isMatch: false,
                    startIndex: startIndex,
                    endIndex: index
                ))
                currentMismatch = ""
            }
            originalDiffs.append(TextDifference(
                text: String(char),
                isMatch: true,
                startIndex: index,
                endIndex: index + 1
            ))
            lcsIndex += 1
        } else {
            if currentMismatch.isEmpty {
                startIndex = index
            }
            currentMismatch.append(char)
        }
    }
    
    if !currentMismatch.isEmpty {
        originalDiffs.append(TextDifference(
            text: currentMismatch,
            isMatch: false,
            startIndex: startIndex,
            endIndex: originalChars.count
        ))
    }
    
    // ËØÜÂà´ÊñáÊú¨ÁöÑÂ∑ÆÂºÇÊ†áËÆ∞
    let recognizedDiffs = recognizedChars.map { char in
        TextDifference(text: String(char), isMatch: true, startIndex: 0, endIndex: 1)
    }
    
    return (originalDiffs, recognizedDiffs)
}


struct PracticeListView: View {
    let topicId: Int
    @StateObject private var dbManager = DatabaseManager.shared
    @State private var searchText = ""
    @State private var selectedFilter: FilterType = .all
    @State private var isLoading = false
    @State private var showLoadingOverlay = false
    
    var filteredItems: [PracticeItem] {
        // È¶ñÂÖàËøáÊª§ÂΩìÂâç‰∏ìÈ¢òÁöÑÁªÉ‰π†È¢ò
        let topicItems = dbManager.practiceItems
        
        // ÁÑ∂ÂêéÂ∫îÁî®ÊêúÁ¥¢ËøáÊª§
        let searchFiltered = topicItems.filter { item in
            searchText.isEmpty || item.title.localizedCaseInsensitiveContains(searchText)
        }
        
        // ÊúÄÂêéÂ∫îÁî®Á±ªÂûãËøáÊª§
        switch selectedFilter {
        case .all:
            return searchFiltered
        case .recent:
            return searchFiltered  // Êï∞ÊçÆÂ∫ìÂ±ÇÈù¢Â∑≤ÁªèËøáÊª§
        case .unreadOnly:
            return searchFiltered.filter { !($0.isRead ?? false) }
        }
    }
    
    var body: some View {
        ZStack {
            List(filteredItems) { item in
                NavigationLink {
                    PracticeRoomView(item: item)
                } label: {
                    PracticeItemRow(item: item)
                }
            }
            .navigationTitle("Âè£ËØ≠ÁªÉ‰π†")
            .searchable(text: $searchText, prompt: "ÊêúÁ¥¢ÁªÉ‰π†")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Menu {
                        Picker("Á≠õÈÄâÊñπÂºè", selection: $selectedFilter) {
                            HStack {
                                Image(systemName: "list.bullet")
                                Text("ÂÖ®ÈÉ®")
                            }
                            .tag(FilterType.all)
                            
                            HStack {
                                Image(systemName: "clock")
                                Text("ÊúÄËøëÈòÖËØª")
                            }
                            .tag(FilterType.recent)
                            
                            HStack {
                                Image(systemName: "book.closed")
                                Text("Êú™ËØª")
                            }
                            .tag(FilterType.unreadOnly)
                        }
                    } label: {
                        Image(systemName: getFilterIcon())
                    }
                }
            }
            
            if showLoadingOverlay {
                ZStack {
                    Color.black.opacity(0.3)
                        .ignoresSafeArea()
                    
                    VStack(spacing: 20) {
                        ProgressView()
                            .scaleEffect(1.5)
                        Text("Âä†ËΩΩ‰∏≠...")
                            .foregroundColor(.white)
                    }
                    .padding()
                    .background(Color(UIColor.systemBackground))
                    .cornerRadius(10)
                    .shadow(radius: 10)
                }
                .transition(.opacity)
            }
        }
        .onAppear {
            dbManager.currentTopicId = topicId
            print("üé¨ PracticeListView Âá∫Áé∞")
            Task {
                showLoadingOverlay = true
                await loadItems(filter: selectedFilter)
            }
        }
        .onChange(of: selectedFilter) { newFilter in
            print("üîÑ ËøáÊª§Ê®°ÂºèÊîπÂèò: \(newFilter)")
            Task {
                showLoadingOverlay = true
                await loadItems(filter: newFilter)
            }
        }
    }
    
    private func getFilterIcon() -> String {
        switch selectedFilter {
        case .all:
            return "line.3.horizontal.decrease.circle"
        case .recent:
            return "clock"
        case .unreadOnly:
            return "book.closed"
        }
    }
    
    private func loadItems(filter: FilterType) async {
        isLoading = true
        showLoadingOverlay = true
        
        await Task.yield()
        
        await MainActor.run {
            switch filter {
            case .all, .unreadOnly:
                dbManager.loadPracticeItems(filter: .all)
            case .recent:
                dbManager.loadPracticeItems(filter: .recent)
            }
        }
        
        // Ê∑ªÂä†Â∞èÂª∂Ëøü‰ª•Á°Æ‰øùÂä†ËΩΩÂä®ÁîªÊµÅÁïÖ
        if !isLoading {
            try? await Task.sleep(nanoseconds: 500_000_000)
        }
        
        await MainActor.run {
            isLoading = false
            withAnimation {
                showLoadingOverlay = false
            }
        }
    }
}

// ‰øÆÊîπ PracticeRoomView
struct PracticeRoomView: View {
    let item: PracticeItem
    @StateObject private var audioManager = AudioManager.shared
    @StateObject private var dbManager = DatabaseManager.shared
    @State private var selectedTab = 0
    @Environment(\.presentationMode) var presentationMode
    
    var body: some View {
        VStack(spacing: 0) {
            // Ëá™ÂÆö‰πâÈ°∂ÈÉ®Ê†áÁ≠æÊ†è
            HStack(spacing: 0) {
                TabButton(
                    title: "ÊñáÁ´†",
                    systemImage: "doc.text",
                    isSelected: selectedTab == 0
                ) {
                    selectedTab = 0
                }
                
                TabButton(
                    title: "ÁªÉ‰π†ËÆ∞ÂΩï",
                    systemImage: "waveform",
                    isSelected: selectedTab == 1
                ) {
                    selectedTab = 1
                }
            }
            .padding(.horizontal)
            .padding(.top, 8)
            
            Divider()
                .padding(.top, 8)
            
            // ÂÜÖÂÆπÂå∫Âüü
            TabView(selection: $selectedTab) {
                ArticleView(item: item)
                    .tag(0)
                
                RecordingsView(recordings: dbManager.recordings)
                    .tag(1)
            }
            .tabViewStyle(.page(indexDisplayMode: .never))
        }
        .navigationTitle(item.title)
        .navigationBarTitleDisplayMode(.inline)
        .onAppear {
            if let id = item.id {
                dbManager.loadRecordings(for: id)
            }
        }
        .interactiveDismissDisabled()
    }
}

// Ê∑ªÂä†Ëá™ÂÆö‰πâÊ†áÁ≠æÊåâÈíÆ
struct TabButton: View {
    let title: String
    let systemImage: String
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 4) {
                HStack(spacing: 4) {
                    Image(systemName: systemImage)
                        .font(.system(size: 16))
                    Text(title)
                        .font(.headline)
                }
                .foregroundColor(isSelected ? .blue : .gray)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 8)
                
                // Â∫ïÈÉ®ÊåáÁ§∫Êù°
                Rectangle()
                    .fill(isSelected ? Color.blue : Color.clear)
                    .frame(height: 2)
            }
        }
    }
}


//
struct PracticeItemRow: View {
    let item: PracticeItem
    @StateObject private var dbManager = DatabaseManager.shared
    @State private var highestScore: Int = 0
    @State private var practiceCount: Int = 0
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text(item.title)
                    .font(.headline)
                    .foregroundColor(practiceCount == 0 ? .red : .primary)
                    .lineLimit(1)  // ÈôêÂà∂‰∏∫ÂçïË°å
                    .truncationMode(.tail)  // ‰ΩøÁî®ÁúÅÁï•Âè∑
                
                Spacer(minLength: 8)  // ÊúÄÂ∞èÈó¥Ë∑ù
                
                if practiceCount == 0 {
                    Text("NEW")
                        .font(.caption)
                        .fontWeight(.bold)
                        .foregroundColor(.white)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.red)
                        .cornerRadius(4)
                } else {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.green)
                }
            }
            
            HStack {
                if highestScore > 0 {
                    Text("ÊúÄÈ´òÂàÜ: \(highestScore)")
                        .font(.caption)
                        .foregroundColor(.green)
                } else {
                    Text("Êú™ÁªÉ‰π†")
                        .font(.caption)
                        .foregroundColor(.red)
                }
                
                Spacer()
                
                HStack(spacing: 4) {
                    Image(systemName: "mic.fill")
                    Text("\(practiceCount)Ê¨°")
                }
                .font(.caption)
                .padding(4)
                .background(Color.blue.opacity(0.2))
                .cornerRadius(4)
            }
        }
        .onAppear {
            loadStats()
        }
    }
    
    private func loadStats() {
        if let id = item.id {
            let stats = dbManager.loadPracticeStats(for: id)
            self.practiceCount = stats.practiceCount
            self.highestScore = stats.highestScore
        }
    }
}
 

// Ê∑ªÂä† ArticleView
struct ArticleView: View {
    let item: PracticeItem
    @StateObject private var audioManager = AudioManager.shared
    @StateObject private var dbManager = DatabaseManager.shared
    @StateObject private var speechRecognizer = SpeechRecognizer()
    @StateObject private var ttsManager = TTSManager.shared
    
    var body: some View {
        VStack {
            ScrollView {
                Text(item.content)
                    .padding()
            }
            
            Button(action: {
                if audioManager.isPlaying {
                    audioManager.stopPlaying()
                } else {
                    if !item.mp3Url.isEmpty {
                        // Â§ÑÁêÜÂèòÈáèÊõøÊç¢
                        let playUrl = item.mp3Url.replacingOccurrences(
                            of: ".content",
                            with: item.content.addingPercentEncoding(
                                withAllowedCharacters: .urlQueryAllowed
                            ) ?? ""
                        )
                        audioManager.playStreamingAudio(url: playUrl)
                    } else {
                        audioManager.playContent(item.content)
                    }
                }
            }) {
                HStack {
                    Image(systemName: audioManager.isPlaying ? "pause.circle.fill" : "play.circle.fill")
                        .font(.title)
                    Text(audioManager.isPlaying ? "ÊöÇÂÅú" : "Êí≠Êîæ")
                    if item.mp3Url.isEmpty {
                        Text("(Á≥ªÁªüÊúóËØª)")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                .foregroundColor(.blue)
                .padding()
            }
            
            // Â¶ÇÊûúÊòØÁ≥ªÁªüÊúóËØªÔºåÊ∑ªÂä†ËØ≠ÈÄüÊéßÂà∂
            if item.mp3Url.isEmpty {
                HStack {
                    Text("ËØ≠ÈÄü")
                    Slider(
                        value: Binding(
                            get: { Double(ttsManager.speechRate) },
                            set: { ttsManager.speechRate = Float($0) }
                        ),
                        in: 0.1...0.75
                    )
                }
                .padding(.horizontal)
            }
            
            Divider()
            
            RecordButton(item: item)
                .frame(height: 100)
                .padding(.bottom)
        }
    }
}

// ‰øÆÊîπ RecordingsView
struct RecordingsView: View {
    @StateObject private var audioManager = AudioManager.shared
    @StateObject private var dbManager = DatabaseManager.shared
    let recordings: [Recording]
    
    var body: some View {
        List {
            ForEach(recordings) { recording in
                RecordingRow(recording: recording)
                    .contextMenu {  // ‰ΩøÁî®ÈïøÊåâËèúÂçïÊõø‰ª£ÊªëÂä®Âà†Èô§
                        Button(role: .destructive) {
                            // Âà†Èô§ÂΩïÈü≥Êñá‰ª∂
                            let fileURL = recording.fileURL
                            try? FileManager.default.removeItem(at: fileURL)
                            
                            // Âà†Èô§Êï∞ÊçÆÂ∫ìËÆ∞ÂΩï
                            dbManager.deleteRecording(recording)
                            
                            // ÈáçÊñ∞Âä†ËΩΩÂΩïÈü≥ÂàóË°®
                            dbManager.loadRecordings(for: recording.practiceItemId)
                        } label: {
                            Label("Âà†Èô§", systemImage: "trash")
                        }
                    }
            }
        }
    }
}


// Ê∑ªÂä† RecordButton
struct RecordButton: View {
    @StateObject private var audioManager = AudioManager.shared
    @StateObject private var dbManager = DatabaseManager.shared
    @StateObject private var speechRecognizer = SpeechRecognizer()
    let item: PracticeItem
    
    // ÊâãÂäøÁä∂ÊÄÅ
    @State private var isRecording = false
    @State private var dragOffset: CGSize = .zero
    @State private var recordingStartTime: Date?
    @State private var recordingURL: URL?
    
    // ÊãñÂä®ÈòàÂÄº
    let cancelThreshold: CGFloat = -100  // Â∑¶ÊªëÂèñÊ∂à
    let completeThreshold: CGFloat = 100 // Âè≥ÊªëÂÆåÊàê
    
    var body: some View {
        GeometryReader { geometry in
            HStack {
                // Â∑¶‰æßÊ∂àÊåáÁ§∫
                if isRecording {
                    Image(systemName: "xmark.circle.fill")
                        .font(.system(size: 24))
                        .foregroundColor(.red.opacity(
                            dragOffset.width < 0 ? 
                            min(1.0, abs(dragOffset.width) / abs(cancelThreshold)) : 0.3
                        ))
                        .frame(width: 44)
                        .animation(.easeOut, value: dragOffset)
                }
                
                Spacer()
                
                VStack {
                    // ÂΩïÈü≥Áä∂ÊÄÅÊèêÁ§∫
                    if isRecording {
                        Text(
                            dragOffset.width < cancelThreshold ? "ÊùæÂºÄÂèñÊ∂à" :
                            dragOffset.width > completeThreshold ? "ÊùæÂºÄÂÆåÊàê" :
                            "Â∑¶ÊªëÂèñÊ∂àÔºåÂè≥ÊªëÂÆåÊàê"
                        )
                        .foregroundColor(
                            dragOffset.width < cancelThreshold ? .red :
                            dragOffset.width > completeThreshold ? .green :
                            .primary
                        )
                        .animation(.easeOut, value: dragOffset)
                    }
                    
                    // ÂΩïÈü≥Êó∂Èïø
                    if isRecording {
                        Text(String(format: "%.1f", audioManager.currentTime))
                            .font(.title)
                            .foregroundColor(.red)
                    }
                    
                    // ÂΩïÈü≥ÊåâÈíÆ
                    Circle()
                        .fill(isRecording ? Color.red : Color.blue)
                        .frame(width: 64, height: 64)
                        .overlay(
                            Image(systemName: "mic.fill")
                                .foregroundColor(.white)
                                .font(.system(size: 24))
                        )
                        .offset(x: dragOffset.width)
                        .gesture(
                            DragGesture()
                                .onChanged { gesture in
                                    if isRecording {
                                        dragOffset = gesture.translation
                                    }
                                }
                                .onEnded { _ in
                                    handleRecordingEnd()
                                }
                        )
                        .simultaneousGesture(
                            LongPressGesture(minimumDuration: 0.1)
                                .onEnded { _ in
                                    startRecording()
                                }
                        )
                        .animation(.spring(), value: dragOffset)
                }
                
                Spacer()
                
                // Âè≥‰æßÂÆåÊàêÊåáÁ§∫
                if isRecording {
                    Image(systemName: "checkmark.circle.fill")
                        .font(.system(size: 24))
                        .foregroundColor(.green.opacity(
                            dragOffset.width > 0 ? 
                            min(1.0, dragOffset.width / completeThreshold) : 0.3
                        ))
                        .frame(width: 44)
                        .animation(.easeOut, value: dragOffset)
                }
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
            .padding(.horizontal)
        }
    }
    
    private func startRecording() {
        recordingURL = audioManager.startRecording()
        isRecording = true
        recordingStartTime = Date()
    }
    
    private func handleRecordingEnd() {
        defer {
            isRecording = false
            dragOffset = .zero
            recordingStartTime = nil
        }
        
        guard let url = recordingURL else { return }
        
        let duration = audioManager.stopRecording()
        
        // Ê†πÊçÆÊãñÂä®Ë∑ùÁ¶ªÂÆöÂÆåÊàêËøòÊòØÂèñÊ∂à
        if dragOffset.width < cancelThreshold {
            // Â∑¶ÊªëÂèñÊ∂àÂΩïÈü≥
            try? FileManager.default.removeItem(at: url)
        } else if dragOffset.width > completeThreshold || duration >= 1.0 {
            // Âè≥ÊªëÂÆåÊàêÂΩïÈü≥ÔºàÊàñÂΩïÈü≥Êó∂ÈïøË∂ÖËøá1ÁßíÔºâ
            let recording = Recording(
                practiceItemId: item.id ?? 0,
                date: recordingStartTime ?? Date(),
                duration: duration,
                fileURL: url
            )
            dbManager.saveRecording(recording)
            handleRecordingFinished(recording)
        } else {
            // ÊªëÂä®Ë∑ùÁ¶ª‰∏çÂ§üÔºåËßÜ‰∏∫ÂèñÊ∂à
            try? FileManager.default.removeItem(at: url)
        }
    }
    
    private func handleRecordingFinished(_ recording: Recording) {
        Task {
            do {
                let transcribedText = try await speechRecognizer.transcribeAudio(url: recording.fileURL)
                let scoreManager = ScoreManager()
                let (similarity, mismatches) = scoreManager.calculateScore(
                    original: item.content,
                    transcribed: transcribedText
                )
                
                let score = SpeechScore(
                    recordingId: recording.id,
                    transcribedText: transcribedText,
                    matchScore: similarity,
                    mismatchedWords: mismatches
                )
                
                await MainActor.run {
                    dbManager.saveScore(score)
                }
            } catch {
                print("Speech recognition error: \(error)")
            }
        }
    }
}



